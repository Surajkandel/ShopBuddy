// models/UserInteraction.js
const mongoose = require('mongoose');

const userInteractionSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  productId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Product',
    required: true
  },
  interactionType: {
    type: String,
    enum: ['view', 'like', 'purchase', 'cart', 'wishlist'],
    required: true
  },
  rating: {
    type: Number,
    min: 1,
    max: 5
  },
  timestamp: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('UserInteraction', userInteractionSchema);

// services/recommendationService.js
const Product = require('../models/Product');
const UserInteraction = require('../models/UserInteraction');

class RecommendationService {
  
  // Content-based filtering: Recommend similar products
  async getContentBasedRecommendations(userId, productId, limit = 5) {
    try {
      const targetProduct = await Product.findById(productId);
      if (!targetProduct) return [];

      // Find products in same category/subcategory with similar price range
      const priceRange = targetProduct.price * 0.3; // 30% price variance
      
      const recommendations = await Product.find({
        _id: { $ne: productId },
        $or: [
          { category: targetProduct.category, subcategory: targetProduct.subcategory },
          { 
            category: targetProduct.category,
            price: { 
              $gte: targetProduct.price - priceRange,
              $lte: targetProduct.price + priceRange 
            }
          }
        ],
        stock: { $gt: 0 }
      })
      .sort({ createdAt: -1 })
      .limit(limit);

      return recommendations;
    } catch (error) {
      console.error('Content-based recommendation error:', error);
      return [];
    }
  }

  // Collaborative filtering: Users who liked this also liked
  async getCollaborativeRecommendations(userId, limit = 5) {
    try {
      // Get user's interactions
      const userInteractions = await UserInteraction.find({ 
        userId,
        interactionType: { $in: ['like', 'purchase', 'cart'] }
      }).populate('productId');

      if (userInteractions.length === 0) {
        return this.getPopularProducts(limit);
      }

      const userProductIds = userInteractions.map(interaction => interaction.productId._id);

      // Find users with similar interactions
      const similarUsers = await UserInteraction.aggregate([
        {
          $match: {
            productId: { $in: userProductIds },
            userId: { $ne: userId },
            interactionType: { $in: ['like', 'purchase', 'cart'] }
          }
        },
        {
          $group: {
            _id: '$userId',
            commonProducts: { $sum: 1 }
          }
        },
        {
          $match: { commonProducts: { $gte: 2 } }
        },
        {
          $sort: { commonProducts: -1 }
        },
        {
          $limit: 10
        }
      ]);

      if (similarUsers.length === 0) {
        return this.getPopularProducts(limit);
      }

      const similarUserIds = similarUsers.map(user => user._id);

      // Get products liked by similar users but not by current user
      const recommendations = await UserInteraction.aggregate([
        {
          $match: {
            userId: { $in: similarUserIds },
            productId: { $nin: userProductIds },
            interactionType: { $in: ['like', 'purchase'] }
          }
        },
        {
          $group: {
            _id: '$productId',
            score: { $sum: 1 }
          }
        },
        {
          $sort: { score: -1 }
        },
        {
          $limit: limit
        },
        {
          $lookup: {
            from: 'products',
            localField: '_id',
            foreignField: '_id',
            as: 'product'
          }
        },
        {
          $unwind: '$product'
        },
        {
          $match: {
            'product.stock': { $gt: 0 }
          }
        },
        {
          $replaceRoot: { newRoot: '$product' }
        }
      ]);

      return recommendations.length > 0 ? recommendations : this.getPopularProducts(limit);
    } catch (error) {
      console.error('Collaborative recommendation error:', error);
      return [];
    }
  }

  // Popular products based on interactions
  async getPopularProducts(limit = 5) {
    try {
      const popularProducts = await UserInteraction.aggregate([
        {
          $match: {
            interactionType: { $in: ['view', 'like', 'purchase'] },
            timestamp: { $gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) } // Last 30 days
          }
        },
        {
          $group: {
            _id: '$productId',
            viewCount: {
              $sum: { $cond: [{ $eq: ['$interactionType', 'view'] }, 1, 0] }
            },
            likeCount: {
              $sum: { $cond: [{ $eq: ['$interactionType', 'like'] }, 2, 0] }
            },
            purchaseCount: {
              $sum: { $cond: [{ $eq: ['$interactionType', 'purchase'] }, 5, 0] }
            }
          }
        },
        {
          $addFields: {
            totalScore: { $add: ['$viewCount', '$likeCount', '$purchaseCount'] }
          }
        },
        {
          $sort: { totalScore: -1 }
        },
        {
          $limit: limit
        },
        {
          $lookup: {
            from: 'products',
            localField: '_id',
            foreignField: '_id',
            as: 'product'
          }
        },
        {
          $unwind: '$product'
        },
        {
          $match: {
            'product.stock': { $gt: 0 }
          }
        },
        {
          $replaceRoot: { newRoot: '$product' }
        }
      ]);

      return popularProducts;
    } catch (error) {
      console.error('Popular products error:', error);
      return [];
    }
  }

  // Category-based recommendations
  async getCategoryRecommendations(userId, category, limit = 5) {
    try {
      // Get user's purchase history in this category
      const userPurchases = await UserInteraction.find({
        userId,
        interactionType: 'purchase'
      }).populate({
        path: 'productId',
        match: { category }
      });

      const purchasedProductIds = userPurchases
        .filter(interaction => interaction.productId)
        .map(interaction => interaction.productId._id);

      // Get top-rated products in category that user hasn't purchased
      const recommendations = await Product.find({
        category,
        _id: { $nin: purchasedProductIds },
        stock: { $gt: 0 }
      })
      .sort({ createdAt: -1 })
      .limit(limit);

      return recommendations;
    } catch (error) {
      console.error('Category recommendation error:', error);
      return [];
    }
  }

  // Price-based recommendations (similar price range)
  async getPriceBasedRecommendations(targetPrice, category = null, limit = 5) {
    try {
      const priceRange = targetPrice * 0.2; // 20% variance
      
      const query = {
        price: {
          $gte: targetPrice - priceRange,
          $lte: targetPrice + priceRange
        },
        stock: { $gt: 0 }
      };

      if (category) {
        query.category = category;
      }

      const recommendations = await Product.find(query)
        .sort({ selling_price: 1 }) // Sort by best deals first
        .limit(limit);

      return recommendations;
    } catch (error) {
      console.error('Price-based recommendation error:', error);
      return [];
    }
  }

  // Hybrid recommendation system
  async getHybridRecommendations(userId, options = {}) {
    try {
      const {
        includeContentBased = true,
        includeCollaborative = true,
        includePopular = true,
        limit = 10
      } = options;

      let allRecommendations = [];

      // Get different types of recommendations
      if (includeCollaborative) {
        const collaborative = await this.getCollaborativeRecommendations(userId, Math.ceil(limit * 0.4));
        allRecommendations.push(...collaborative.map(p => ({ ...p, source: 'collaborative', score: 3 })));
      }

      if (includeContentBased) {
        // Get user's recent interactions to base content recommendations on
        const recentInteractions = await UserInteraction.find({ userId })
          .sort({ timestamp: -1 })
          .limit(3)
          .populate('productId');

        for (const interaction of recentInteractions) {
          if (interaction.productId) {
            const contentBased = await this.getContentBasedRecommendations(
              userId, 
              interaction.productId._id, 
              Math.ceil(limit * 0.3)
            );
            allRecommendations.push(...contentBased.map(p => ({ ...p, source: 'content', score: 2 })));
          }
        }
      }

      if (includePopular) {
        const popular = await this.getPopularProducts(Math.ceil(limit * 0.3));
        allRecommendations.push(...popular.map(p => ({ ...p, source: 'popular', score: 1 })));
      }

      // Remove duplicates and sort by score
      const uniqueRecommendations = [];
      const seenIds = new Set();

      for (const rec of allRecommendations) {
        const id = rec._id.toString();
        if (!seenIds.has(id)) {
          seenIds.add(id);
          uniqueRecommendations.push(rec);
        }
      }

      // Sort by score (collaborative > content > popular) and limit results
      return uniqueRecommendations
        .sort((a, b) => b.score - a.score)
        .slice(0, limit)
        .map(rec => {
          const { source, score, ...product } = rec;
          return product;
        });

    } catch (error) {
      console.error('Hybrid recommendation error:', error);
      return [];
    }
  }

  // Track user interaction
  async trackInteraction(userId, productId, interactionType, rating = null) {
    try {
      const interaction = new UserInteraction({
        userId,
        productId,
        interactionType,
        rating
      });

      await interaction.save();
      return interaction;
    } catch (error) {
      console.error('Track interaction error:', error);
      return null;
    }
  }
}

module.exports = new RecommendationService();